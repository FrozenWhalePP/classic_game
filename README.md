1 引言
======

《贪吃蛇》风靡一时。在若干年前，诺基亚还是市场主流得到的时候，贪吃蛇是人人皆知的一款手机游戏。最初的贪吃蛇，仅仅可以控制上下左右，依赖于吃掉食物而变长。必须特别注意，撞到自己或者墙则会输掉！随着智能手机的普及，贪吃蛇的玩法也更加多样，其不仅仅是在黑白会的极简屏幕的游戏，场景变得更加丰富，城市、山野等，还设置了不同的食物、不同的地形。再随着互联网的普及，在线对战成为主流，像"贪吃蛇大作战"等游戏也火爆一时，这时，蛇不再拘泥于上下左右四个方向，而是由触控板进行灵活的控制。

尽管玩法变得更加多样，但游戏的核心不曾改变。玩家通过控制方向，控制蛇的移动，目标是吃掉地图上的食物得分，同时身体变长。玩家需要灵活调整，以躲避墙壁和自身，尽可能得到高的分数。

本项目使用Java实现了简单的贪吃蛇，拥有较为良好的GUI界面，玩家通过上下左右控制蛇的移动，可以设置游戏难度，即设置蛇的移动速度。当吃掉食物后，身体变长，同时得分。游戏简单，但涉及的技术较为全面。

2 设计依据及框图
================

2.1 设计平台
------------

项目使用Eclipse进行开发。Eclipse是一款开源IDE，和IntelliJ
IDEA并为当下最流行的IDE。其本身使用Java开发，占据内存相对IDEA较小，且学习资料完善。使用Eclipse开发Java应用十分方便，自动补全、语法检查等辅助功能也极大提高了编程效率，避免花时间在不必要的时间，而专心核心逻辑和界面的实现。

2.2 设计思想
------------

### 2.2.1 面向对象

和C语言等非OOP语言相比，Java作为完全面向对象的高级编程语言，应充分考虑这一点，发挥优势，进行合理的封装。在本项目中，蛇是一个对象，但是考虑到其动态变化，实质上是一系列结点的变化，因此，封装了SnakeCell类，作为蛇的基本单元。同时，对食物进行了封装，为FoodCell类。注意到它们实际上都位于画板Jpanel上，且位于画板分隔成的单元格中，有一定的相似之处。因此，封装了抽象基类Cell类，使FoodCell类和SnakeCell类继承自Cell类，实现对应的方法，体现它们的不同。

此外，作为地图，封装了SnakeMap类，其也是游戏的核心逻辑类，记录了一系列游戏状态和游戏元素，实现了各类逻辑处理。其内部拥有一个线程类，负责蛇的移动。游戏的主要窗口则是SnakeApp类，负责开始游戏、设置难度等操作。

2.3 系统总体结构框图
--------------------

系统主要分为五个模块，分别是地图生成，食物设置，蛇的移动，进程判定和界面设计。

![](https://frozenwhale.oss-cn-beijing.aliyuncs.com/img/20200531204756.png)

3 各模块功能实现
================

3.1 地图生成
------------



![](https://frozenwhale.oss-cn-beijing.aliyuncs.com/img/20200531204822.png)

地图的基本单元是Cell（SnakeCell）。Cell类为抽象基类，设置了坐标xy以及方格宽度wid，以及方格的背景颜色，实现了基本的setter和getter方法。Cell类声明了一个抽象函数draw()，该函数传入参数为Graphics2D，用以绘制图像。Cell的子类必须重写实现这个方法。

地图设置了属性w表示宽，h表示高。一张地图包含了一个二维数组：SnakeCell\[\]\[\]
cells，这是一系列单元格。地图的初始化使用二重循环，单元格类型使用子类SnakeCell类。这是由于，在后续蛇的移动时，可以认为是将地图上的单元格变为自己的身体。



初始化地图后，需要限定边界。封装了initBorder()方法，边界设置使用两个循环，分别对横向和纵向进行初始化。注意，绘制时传入的参数是单元格的位置索引，而不是其在屏幕中的绝对位置，这是由于我们在绘制的时候，已经实现了位置和坐标的转化。使用位置，能够更好地控制相对方位，在调整位置时，只调整边界即可。

3.2 食物设置
------------

食物的设置分为两大部分，一是完成初始化，而是被蛇吃掉后重新设置。我们可以将其封装为函数initFood()，该方法随机产生位置。

引入随机数类Random，产生范围\[0, w-1\]和\[0,
h-1\]的两个位置变量，需要注意，食物的有效位置不包括边界和蛇的身体（头部），因此需要排除这些位置。使用循环控制，每次产生时，遍历蛇的位置和边界的位置，如果重合，则继续产生新的坐标，直到不重合。

当食物被吃掉后，只需要调用initFood()方法，即可重新设置食物的位置。需要注意的是，可能两次设置食物在同一地点，这也是符合游戏设定的。

3.3 蛇的移动
------------

为了实现蛇这一对象，使用链表数据结构来表示蛇。使用List\<SnakeCell\>
cellList = new LinkedList\<SnakeCell\>
来初始化一个蛇。蛇由一系列的SnakeCell构成，将这些SnakeCell设置为不同的颜色即可表示蛇和蛇头。为了方便处理，特别记录SnakeCell
head，表示蛇的头。

在SnakeMap类里，实现了对蛇的相关操作。记录了蛇的长度len，给定len=5为默认初始长度。游戏开始前，在地图中设置蛇的位置坐标，将同一排列方向上的5个单元格加入到蛇链表中，并设置第一个单元格为头部head。

至此，一条静止的蛇已经实现。为了进一步的移动，需要确定移动方向，因此，封装了枚举类Direction表示上下左右四个方向，并在SnakeMap类内记录当前移动方向。蛇方向的改变由用户键盘方向键控制，因此，需要添加对应的键盘监听事件。需要注意的是，我们不允许蛇直接掉头移动，因此需要判断当前的移动方向和输入的方向的关系，只有二者非反向时，移动有效，改变方向。由于一个界面只能由一个组件接受键盘输入，所以需要设置画布焦点：setFocusable(true)。

为了实现移动，需要一个线程类。定义内部线程类MoveThread，方便数据的使用。该线程类记录了当前的状态boolen
live，当live = false时，线程结束。

重写run()方法。设置蛇的移动速度speed（1-20），使用倒数\*1000即(1000/speed)作为刷新间隔，使用Thead.sleep()方法实现。Speed越大，蛇的移动越快。设定蛇在单位时间内移动一个单元格，这可以通过在蛇的前进方向前添加一个单元格作为新的蛇头head，同时移除位于蛇尾部的单元格，并设置相应的颜色。我们需要得到当前蛇头的位置坐标，然后根据移动方向判断下一时间的位置.

如此不断进行，就实现了蛇的移动。

3.4 进程判断
------------

### 3.4.1 蛇的成长

蛇在吃掉食物后会变长，而吃掉食物通过判断蛇头head和食物的位置关系即可得到。抽象成函数eatFood()，在每次移动后进行判断：

```JAVA
    private boolean eatFood(){
        return head.getX() == food.getX() && head.getY() == food.getY();
    }
```

蛇的边长可以较为简单的实现。由于蛇移动的原理是添加新的头部结点，删除尾部结点，可以认为蛇边长是在尾部新加一个结点，这等效于不删除尾部结点。

###  3.4.2 越界判断

蛇撞到边界即游戏失败，这可以通过遍历组成边界的单元格，依次判断其是否和当前头部head的位置重合，如果重合则游戏失败。SS

###  3.4.3 自咬判断

当蛇太长时，如果撞到自己游戏失败。这与越界判断类似，需要遍历蛇的身体的结点，比较是否和头部head重合，如果重合则失败。需要注意的是，由于我们使用了链表结构LinkedList，使用for循环按照索引的方法，会使得时间复杂度很高，而使用迭代器可以快速遍历。Java中可以使用for(Object obj :objectList)的方式，但是我们需要跳过头部结点，因此使用一个额外的变量来标记即可。

3.5 样式设置
------------

对颜色进行了封装，定义GameColor类。因此，如果想要改变样式，只需要修改对应的颜色类即可，从而提高了代码的可维护性。

类SnakeApp继承自JFrame窗口类，布局采用BorderLayout，上方（North）设置toolBar
(Jtoolbar)，在其中放置Jlabel以显示游戏得分，下方（South）使用另一个toolbar，放置Jbutton，实现开始游戏、难度设置的操作。在中间（Center）放置游戏核心区SnakeMap，该类继承自Jpanel。

SnakeMap重写了paintComponent方法来进行重绘。分别绘制蛇身体，边界和食物，逻辑清晰。

胜利以及失败提示使用JoptionPane.showMessageDialog实现，难度设置使用JoptionPane.showInputDialog实现，得到用户输入。

4 调试分析
==============

4.1 执行逻辑分析
----------------

得益于良好的类和函数的设计，程序的执行逻辑清晰。由App类负责初始化整个窗口界面和应用组件，并接受相应的事件监听，将其传递给SnakeMap，实现逻辑操作。SnakeMap记录了一系列属性，明确游戏状态。抽象出init方法，在构造和重设时十分清晰。

```java
    initComponents(); // 初始化组件

    initMap(); // 初始化地图

    initBorder(); // 初始化边界

    initSnake(); // 初始化蛇

    initFood(); // 初始化食物

    setFocusable(true);                //画布获取焦点

    addKeyListener(new KeyAdapter() // 添加键盘监听
```

游戏的进行由单独的线程控制，并且设置为参数，可以调整。游戏进程的判定抽象出多个函数，使得判断独立、简洁、清晰不易错。

  

```java
    private boolean eatSelf()

    private boolean outBorder()

    private boolean eatFood()
```



4.2 测试
--------

启动SnakeApp的main函数，主界面如下所示。左上角显示得分，下方设置难度和开始游戏。中间是游戏显示区域，边界使用黑色表示，蛇身使用红色，头部使用深红色，食物使用绿色。所有图形均使用方形表示。

![](https://frozenwhale.oss-cn-beijing.aliyuncs.com/img/20200531205432.png)

